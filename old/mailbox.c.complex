/* Mailbox Implementation for Raspberry Pi */

#include "mailbox.h"

// Helper functions
static void mmio_write(uint32_t reg, uint32_t data) {
    *(volatile uint32_t*)reg = data;
}

static uint32_t mmio_read(uint32_t reg) {
    return *(volatile uint32_t*)reg;
}

void mailbox_init(void) {
    // Mailbox is always available, no initialization needed
}

int mailbox_send(uint32_t channel, uint32_t message) {
    // Wait for mailbox to be ready
    while (mmio_read(MAILBOX_STATUS) & MAILBOX_FULL) {
        // Busy wait
    }

    // Combine message and channel
    mmio_write(MAILBOX_WRITE, message | channel);

    return 0;
}

uint32_t mailbox_receive(uint32_t channel) {
    uint32_t data;

    do {
        // Wait for data
        while (mmio_read(MAILBOX_STATUS) & MAILBOX_EMPTY) {
            // Busy wait
        }

        data = mmio_read(MAILBOX_READ);
    } while ((data & 0xF) != channel);  // Check channel

    return data & ~0xF;  // Return message without channel
}

// Property interface implementation
static int mailbox_property_call(property_message_t *msg) {
    uint32_t buf_addr = (uint32_t)msg;
    uint32_t aligned_addr = (buf_addr + 15) & ~15;  // 16-byte aligned

    // Adjust size for alignment
    if (aligned_addr != buf_addr) {
        uint32_t offset = aligned_addr - buf_addr;
        msg = (property_message_t*)aligned_addr;
        msg->size -= offset;
    }

    mailbox_send(MAILBOX_CH_PROP, (uint32_t)msg);
    mailbox_receive(MAILBOX_CH_PROP);

    return msg->code == PROP_RESPONSE_SUCCESS ? 0 : -1;
}

uint32_t mailbox_get_firmware_revision(void) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_FIRMWARE_REV;
    tag->size = 4;
    tag->length = 0;
    tag[1].tag = 0;  // End tag

    if (mailbox_property_call(msg) == 0) {
        return tag->data[0];
    }
    return 0;
}

uint32_t mailbox_get_board_model(void) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_BOARD_MODEL;
    tag->size = 4;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        return tag->data[0];
    }
    return 0;
}

uint32_t mailbox_get_board_revision(void) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_BOARD_REV;
    tag->size = 4;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        return tag->data[0];
    }
    return 0;
}

int mailbox_get_mac_address(uint8_t mac[6]) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_MAC_ADDRESS;
    tag->size = 6;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        for (int i = 0; i < 6; i++) {
            mac[i] = ((uint8_t*)tag->data)[i];
        }
        return 0;
    }
    return -1;
}

uint64_t mailbox_get_serial(void) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_SERIAL;
    tag->size = 8;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        return ((uint64_t)tag->data[1] << 32) | tag->data[0];
    }
    return 0;
}

int mailbox_get_arm_memory(uint32_t *base, uint32_t *size) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_ARM_MEMORY;
    tag->size = 8;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        *base = tag->data[0];
        *size = tag->data[1];
        return 0;
    }
    return -1;
}

int mailbox_get_vc_memory(uint32_t *base, uint32_t *size) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_VC_MEMORY;
    tag->size = 8;
    tag->length = 0;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        *base = tag->data[0];
        *size = tag->data[1];
        return 0;
    }
    return -1;
}

int mailbox_set_clock_rate(uint32_t clock_id, uint32_t rate) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_SET_CLOCK_RATE;
    tag->size = 8;
    tag->length = 8;
    tag->data[0] = clock_id;
    tag->data[1] = rate;
    tag[1].tag = 0;

    return mailbox_property_call(msg);
}

uint32_t mailbox_get_clock_rate(uint32_t clock_id) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_CLOCK_RATE;
    tag->size = 8;
    tag->length = 4;
    tag->data[0] = clock_id;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        return tag->data[1];  // Response rate
    }
    return 0;
}

uint32_t mailbox_get_max_clock_rate(uint32_t clock_id) {
    uint8_t buffer[256] __attribute__((aligned(16)));
    property_message_t *msg = (property_message_t*)buffer;
    property_tag_t *tag = (property_tag_t*)msg->tags;

    msg->size = sizeof(buffer);
    msg->code = 0;
    tag->tag = PROP_TAG_GET_MAX_CLOCK;
    tag->size = 8;
    tag->length = 4;
    tag->data[0] = clock_id;
    tag[1].tag = 0;

    if (mailbox_property_call(msg) == 0) {
        return tag->data[1];  // Max rate
    }
    return 0;
}

pi_model_t pi_get_model(void) {
    uint32_t revision = mailbox_get_board_revision();

    // Handle new style revision codes (bit 23 set)
    if (revision & 0x800000) {
        uint32_t type = (revision >> 4) & 0xFFFF;  // Get full type field

        // Pi 5 B (BCM2712) - highest priority
        if (type == 0x4170 || (type & 0xFF00) == 0xD400) {
            return PI_MODEL_5B;
        }

        // Pi 4 B / 400 (BCM2711)
        if ((type & 0xFF00) == 0x3100) {
            if (type == 0x3130 || type == 0xC130) {
                return PI_MODEL_400;
            }
            return PI_MODEL_4B;
        }

        // Pi Zero 2 W (BCM2837)
        if (type == 0x2120) {
            return PI_MODEL_ZERO_2_W;
        }

        // Pi 3 A+ (BCM2837)
        if (type == 0x20E0) {
            return PI_MODEL_3A_PLUS;
        }

        // Pi 3 B+ (BCM2837)
        if (type == 0x20D3) {
            return PI_MODEL_3B_PLUS;
        }

        // Pi 3 B (BCM2837)
        if ((type & 0xFF00) == 0x2000) {
            return PI_MODEL_3B;
        }

        // Pi Zero W (BCM2835)
        if (type == 0x0C1) {
            return PI_MODEL_ZERO_W;
        }

        // Pi Zero (BCM2835)
        if (type == 0x0092 || type == 0x0093 || type == 0x2093) {
            return PI_MODEL_ZERO;
        }

        // Pi 2 B (BCM2836/BCM2837)
        if (type == 0x1040 || type == 0x1041 || type == 0x2041) {
            return PI_MODEL_2B;
        }

        // Pi 1 A+ (BCM2835)
        if (type == 0x0012 || type == 0x0015 || type == 0x900021) {
            return PI_MODEL_1A_PLUS;
        }

        // Pi 1 B+ (BCM2835)
        if (type == 0x0010 || type == 0x0013 || type == 0x900032) {
            return PI_MODEL_1B_PLUS;
        }

        // Pi 1 B (BCM2835) - catch remaining type 0x1X
        if ((type & 0xF0) == 0x10) {
            return PI_MODEL_1B;
        }

        // Pi 1 A (BCM2835) - catch remaining type 0x0X
        if ((type & 0xF0) == 0x00) {
            return PI_MODEL_1A;
        }

    } else {
        // Old style revision codes (pre-2014)
        switch (revision) {
            case 0x0002: case 0x0003: case 0x0004: case 0x0005:
            case 0x0006: case 0x0007: case 0x0008: case 0x0009:
            case 0x000D: case 0x000E: case 0x000F:
                return PI_MODEL_1B;

            case 0x0010: case 0x0011: case 0x0012: case 0x0013:
            case 0x0014: case 0x0015:
                return PI_MODEL_1B_PLUS;

            default:
                break;
        }
    }

    return PI_MODEL_UNKNOWN;
}