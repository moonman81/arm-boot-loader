/* SD Card and FAT32 Implementation for Raspberry Pi */

#include "sd.h"
#include "uart.h"
#include "hardware.h"

#define MAX_FILE_SIZE 0x1000000  // 16MB limit

// Custom string functions for freestanding environment
static int memcmp(const void *s1, const void *s2, uint32_t n) {
    const unsigned char *p1 = s1, *p2 = s2;
    while (n--) {
        if (*p1 != *p2) return *p1 - *p2;
        p1++; p2++;
    }
    return 0;
}



static void *my_memcpy(void *dest, const void *src, uint32_t n) {
    unsigned char *d = dest;
    const unsigned char *s = src;
    while (n--) *d++ = *s++;
    return dest;
}

// EMMC register offsets
#define EMMC_ARG2_OFFSET       0x00
#define EMMC_BLKSIZECNT_OFFSET 0x04
#define EMMC_ARG1_OFFSET       0x08
#define EMMC_CMDTM_OFFSET      0x0C
#define EMMC_RESP0_OFFSET      0x10
#define EMMC_RESP1_OFFSET      0x14
#define EMMC_RESP2_OFFSET      0x18
#define EMMC_RESP3_OFFSET      0x1C
#define EMMC_DATA_OFFSET       0x20
#define EMMC_STATUS_OFFSET     0x24
#define EMMC_CONTROL0_OFFSET   0x28
#define EMMC_CONTROL1_OFFSET   0x2C
#define EMMC_INTERRUPT_OFFSET  0x30
#define EMMC_IRPT_MASK_OFFSET  0x34
#define EMMC_IRPT_EN_OFFSET    0x38
#define EMMC_CONTROL2_OFFSET   0x3C
#define EMMC_FORCE_IRPT_OFFSET 0x50
#define EMMC_BOOT_TIMEOUT_OFFSET 0x70
#define EMMC_DBG_SEL_OFFSET    0x74
#define EMMC_EXRDFIFO_CFG_OFFSET 0x80
#define EMMC_EXRDFIFO_EN_OFFSET 0x84
#define EMMC_TUNE_STEP_OFFSET  0x88
#define EMMC_TUNE_STEPS_STD (EMMC_BASE + 0x8C)
#define EMMC_TUNE_STEPS_DDR (EMMC_BASE + 0x90)
#define EMMC_SPI_INT_SPT (EMMC_BASE + 0xF0)
#define EMMC_SLOTISR_VER (EMMC_BASE + 0xFC)

// Status flags
#define EMMC_CMD_INHIBIT 0x00000001
#define EMMC_DAT_INHIBIT 0x00000002
#define EMMC_DAT_ACTIVE  0x00000004
#define EMMC_WRITE_TRANS 0x00000800
#define EMMC_READ_TRANS  0x00001000

// FAT globals
static fat_boot_sector_t boot_sector;
static fat_type_t fat_type;
static uint32_t fat_start_sector;
static uint32_t data_start_sector;
static uint32_t root_cluster;
static uint32_t root_dir_sector;
static uint32_t root_dir_sectors;
static uint8_t sectors_per_cluster;

// Helper functions
static void mmio_write(uint32_t reg, uint32_t data) {
    *(volatile uint32_t*)reg = data;
}

static uint32_t mmio_read(uint32_t reg) {
    return *(volatile uint32_t*)reg;
}

static void delay(uint32_t count) {
    while (count--) {
        asm volatile("nop");
    }
}

// SD card functions
static int emmc_wait_for_command(void) {
    uint32_t emmc_base = get_emmc_base();
    uint32_t timeout = 1000000;
    while ((mmio_read(emmc_base + EMMC_STATUS_OFFSET) & EMMC_CMD_INHIBIT) && timeout--) {
        delay(1);
    }
    return timeout > 0 ? 0 : -1;
}

static int emmc_wait_for_data(void) {
    uint32_t emmc_base = get_emmc_base();
    uint32_t timeout = 1000000;
    while ((mmio_read(emmc_base + EMMC_STATUS_OFFSET) & EMMC_DAT_INHIBIT) && timeout--) {
        delay(1);
    }
    return timeout > 0 ? 0 : -1;
}

static int emmc_send_command(uint32_t cmd, uint32_t arg) {
    uint32_t emmc_base = get_emmc_base();
    if (emmc_wait_for_command() < 0) return -1;

    mmio_write(emmc_base + EMMC_ARG1_OFFSET, arg);
    mmio_write(emmc_base + EMMC_CMDTM_OFFSET, cmd);

    if (emmc_wait_for_command() < 0) return -1;

    return 0;
}

int sd_init(void) {
    uint32_t emmc_base = get_emmc_base();
    uart_puts("Initializing EMMC...\n");

    // Reset EMMC
    mmio_write(emmc_base + EMMC_CONTROL0_OFFSET, 0);
    mmio_write(emmc_base + EMMC_CONTROL1_OFFSET, 0);
    delay(1000);

    // Enable EMMC
    mmio_write(emmc_base + EMMC_CONTROL1_OFFSET, 0x00000001);
    delay(1000);

    // Send CMD0 (GO_IDLE_STATE)
    if (emmc_send_command(0x00000000, 0) < 0) {
        uart_puts("CMD0 failed\n");
        return -1;
    }

    // Send CMD8 (SEND_IF_COND)
    if (emmc_send_command(0x080001AA, 0x000001AA) < 0) {
        uart_puts("CMD8 failed\n");
        return -1;
    }

    // Initialize SD card (simplified)
    // This is a basic implementation - full SD spec would be more complex

    uart_puts("EMMC initialized\n");

    // Detect partitions before initializing FAT
    if (partition_detect() < 0) {
        uart_puts("Partition detection failed\n");
        return -1;
    }

    return fat_init();
}

int sd_read_sector(uint32_t sector, uint8_t *buffer) {
    uint32_t emmc_base = get_emmc_base();
    if (emmc_wait_for_data() < 0) return -1;

    // Set block size and count
    mmio_write(emmc_base + EMMC_BLKSIZECNT_OFFSET, 0x00020001); // 512 bytes, 1 block

    // Send CMD17 (READ_SINGLE_BLOCK)
    if (emmc_send_command(0x11000000 | 17, sector) < 0) return -1;

    // Read data
    for (int i = 0; i < 128; i++) { // 512 bytes / 4
        uint32_t data = mmio_read(emmc_base + EMMC_DATA_OFFSET);
        buffer[i*4] = data & 0xFF;
        buffer[i*4+1] = (data >> 8) & 0xFF;
        buffer[i*4+2] = (data >> 16) & 0xFF;
        buffer[i*4+3] = (data >> 24) & 0xFF;
    }

    return 0;
}

// Partition support - MBR and GPT detection for ARM devices
static uint32_t boot_partition_lba = 0;  // LBA of boot partition

int partition_detect(void) {
    uint8_t sector_buffer[512];

    uart_puts("Detecting partition table...\n");

    // Read potential MBR/GPT sector 0
    if (sd_read_sector(0, sector_buffer) < 0) {
        uart_puts("Failed to read sector 0\n");
        return -1;
    }

    // Check MBR signature (last 2 bytes)
    uint16_t mbr_signature = *(uint16_t*)(sector_buffer + 510);
    if (mbr_signature == 0xAA55) {
        uart_puts("MBR detected\n");

        // Parse MBR partitions (start at offset 446)
        for (int i = 0; i < 4; i++) {
            uint8_t *partition = sector_buffer + 446 + (i * 16);
            uint8_t status = partition[0];
            uint8_t type = partition[4];
            uint32_t lba_start = *(uint32_t*)(partition + 8);

            // Check for FAT partition types
            if ((status == 0x80 || status == 0x00) &&  // Bootable or valid
                (type == 0x01 || type == 0x04 || type == 0x06 ||  // FAT12, FAT16
                 type == 0x0B || type == 0x0C || type == 0x0E)) {  // FAT32 variants
                boot_partition_lba = lba_start;
                uart_puts("Found FAT partition at LBA ");
                // Simple print
                char buf[16];
                int len = 0;
                uint32_t temp = lba_start;
                do {
                    buf[len++] = '0' + (temp % 10);
                    temp /= 10;
                } while (temp > 0);
                while (len > 0) uart_putc(buf[--len]);
                uart_puts("\n");
                return 0;
            }
        }
    } else {
        // Check for GPT signature
        uint64_t gpt_signature = *(uint64_t*)sector_buffer;
        if (gpt_signature == 0x5452415020494645ULL) {  // "EFI PART"
            uart_puts("GPT detected\n");

            // Read GPT partition array (usually LBA 2)
            if (sd_read_sector(2, sector_buffer) < 0) {
                uart_puts("Failed to read GPT partition array\n");
                return -1;
            }

            // Check first partition entry for Microsoft Basic Data
            uint8_t *entry = sector_buffer;
            uint8_t ms_basic_data[16] = {0xA2, 0xA0, 0xD0, 0xEB, 0xE5, 0xB9, 0x33, 0x44,
                                       0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7};
            if (memcmp(entry, ms_basic_data, 16) == 0) {
                uint64_t first_lba = *(uint64_t*)(entry + 32);
                boot_partition_lba = (uint32_t)first_lba;
                uart_puts("Found FAT partition in GPT\n");
                return 0;
            }
        }
    }

    // No partition table or no suitable partition found
    uart_puts("No suitable FAT partition found, assuming raw filesystem\n");
    boot_partition_lba = 0;  // Use raw filesystem
    return 0;
}

int partition_read_boot_sector(uint32_t partition_lba, uint8_t *buffer) {
    return sd_read_sector(partition_lba, buffer);
}

// FAT functions - comprehensive FAT12/16/32/exFAT support
int fat_init(void) {
    uint8_t sector_buffer[512];

    uart_puts("Reading boot sector...\n");

    // Use detected partition LBA, or 0 for raw filesystem
    if (sd_read_sector(boot_partition_lba, sector_buffer) < 0) {
        uart_puts("Failed to read boot sector\n");
        return -1;
    }

    // Check for exFAT first
    exfat_boot_sector_t *exfat_bs = (exfat_boot_sector_t*)sector_buffer;
    if (memcmp(exfat_bs->fs_name, "EXFAT   ", 8) == 0) {
        fat_type = EXFAT;
        uart_puts("Detected exFAT filesystem\n");

        // exFAT parameters
        sectors_per_cluster = 1 << exfat_bs->sectors_per_cluster_shift;
        fat_start_sector = exfat_bs->fat_offset;
        data_start_sector = exfat_bs->cluster_heap_offset;
        root_cluster = exfat_bs->root_dir_cluster;

        // exFAT doesn't use traditional root_dir_sector/root_dir_sectors
        root_dir_sector = 0;
        root_dir_sectors = 0;
    } else {
        // Traditional FAT boot sector
        my_memcpy(&boot_sector, sector_buffer, sizeof(fat_boot_sector_t));

        if (boot_sector.bytes_per_sector != 512) {
            uart_puts("Unsupported sector size\n");
            return -1;
        }

        // Determine FAT type
        uint32_t total_sectors = boot_sector.total_sectors_16 ? boot_sector.total_sectors_16 : boot_sector.total_sectors_32;
        uint32_t sectors_per_fat = boot_sector.sectors_per_fat_16 ? boot_sector.sectors_per_fat_16 : boot_sector.sectors_per_fat_32;
        uint32_t data_sectors = total_sectors - (boot_sector.reserved_sectors + (boot_sector.num_fats * sectors_per_fat) + ((boot_sector.root_entries * 32 + boot_sector.bytes_per_sector - 1) / boot_sector.bytes_per_sector));
        uint32_t total_clusters = data_sectors / boot_sector.sectors_per_cluster;

        if (total_clusters < 4085) {
            fat_type = FAT12;
        } else if (total_clusters < 65525) {
            fat_type = FAT16;
        } else {
            fat_type = FAT32;
        }

        sectors_per_cluster = boot_sector.sectors_per_cluster;
        fat_start_sector = boot_sector.reserved_sectors;

        if (fat_type == FAT32) {
            data_start_sector = fat_start_sector + (boot_sector.num_fats * sectors_per_fat);
            root_cluster = boot_sector.root_cluster;
            root_dir_sector = 0; // Not used for FAT32
            root_dir_sectors = 0;
        } else {
            root_dir_sector = fat_start_sector + (boot_sector.num_fats * sectors_per_fat);
            root_dir_sectors = (boot_sector.root_entries * 32 + boot_sector.bytes_per_sector - 1) / boot_sector.bytes_per_sector;
            data_start_sector = root_dir_sector + root_dir_sectors;
            root_cluster = 0; // Not used for FAT12/16
        }
    }

    uart_puts("FAT initialized (type: ");
    if (fat_type == FAT12) uart_puts("12");
    else if (fat_type == FAT16) uart_puts("16");
    else uart_puts("32");
    uart_puts(")\n");
    return 0;
}

int fat_find_file(const char *filename, fat32_dir_entry_t *entry) {
    uint8_t sector_buffer[512];
    char fat_filename[12];

    // Input validation
    if (!filename || !entry) return -1;

    // Convert filename to 8.3 format with bounds checking
    int i = 0;
    // Copy name part (up to 8 characters)
    for (; i < 8 && filename[i] && filename[i] != '.'; i++) {
        fat_filename[i] = filename[i];
    }
    // Pad name with spaces
    for (; i < 8; i++) {
        fat_filename[i] = ' ';
    }
    // Extension part
    fat_filename[8] = ' ';
    fat_filename[9] = ' ';
    fat_filename[10] = ' ';
    // Skip to extension if present
    while (filename[i] && filename[i] != '.') i++;
    if (filename[i] == '.') {
        i++; // Skip the dot
        for (int j = 0; j < 3 && filename[i] && i < 256; i++, j++) { // Prevent runaway with max length check
            fat_filename[8 + j] = filename[i];
        }
    }
    fat_filename[11] = '\0';

    // Search root directory
    uint32_t start_sector, num_sectors;
    if (fat_type == FAT32) {
        start_sector = data_start_sector + (root_cluster - 2) * sectors_per_cluster;
        num_sectors = sectors_per_cluster; // Simplified, should follow cluster chain
    } else {
        start_sector = root_dir_sector;
        num_sectors = root_dir_sectors;
    }

    for (uint32_t s = 0; s < num_sectors; s++) {
        if (sd_read_sector(start_sector + s, sector_buffer) < 0) return -1;

        fat32_dir_entry_t *dir_entries = (fat32_dir_entry_t*)sector_buffer;

        for (int e = 0; e < 512 / sizeof(fat32_dir_entry_t); e++) {
            if (dir_entries[e].name[0] == 0) break; // End of directory
            if (dir_entries[e].name[0] == 0xE5) continue; // Deleted entry

            if (memcmp(dir_entries[e].name, fat_filename, 11) == 0) {
                *entry = dir_entries[e];
                return 0;
            }
        }
    }

    return -1; // File not found
}

static uint32_t fat_get_next_cluster(uint32_t cluster) {
    uint32_t fat_sector, fat_offset;
    uint8_t fat_buffer[512];

    if (fat_type == FAT32) {
        fat_sector = fat_start_sector + (cluster * 4) / 512;
        if (sd_read_sector(fat_sector, fat_buffer) < 0) return 0xFFFFFFFF;
        fat_offset = (cluster * 4) % 512;
        return *(uint32_t*)(fat_buffer + fat_offset) & 0x0FFFFFFF;
    } else if (fat_type == FAT16) {
        fat_sector = fat_start_sector + (cluster * 2) / 512;
        if (sd_read_sector(fat_sector, fat_buffer) < 0) return 0xFFFFFFFF;
        fat_offset = (cluster * 2) % 512;
        return *(uint16_t*)(fat_buffer + fat_offset);
    } else { // FAT12
        uint32_t byte_offset = cluster * 3 / 2;
        fat_sector = fat_start_sector + byte_offset / 512;
        if (sd_read_sector(fat_sector, fat_buffer) < 0) return 0xFFFFFFFF;
        fat_offset = byte_offset % 512;
        uint16_t entry = *(uint16_t*)(fat_buffer + fat_offset);
        if (cluster & 1) {
            return entry >> 4;
        } else {
            return entry & 0x0FFF;
        }
    }
}

int fat_read_file(fat32_dir_entry_t *entry, uint8_t *buffer, uint32_t max_size) {
    uint32_t cluster = (entry->first_cluster_high << 16) | entry->first_cluster_low;
    uint32_t remaining = entry->file_size;
    uint32_t offset = 0;

    uint32_t eof_marker = (fat_type == FAT32) ? 0x0FFFFFF8 : (fat_type == FAT16) ? 0xFFF8 : 0xFF8;

    while (cluster < eof_marker && remaining > 0 && offset < max_size) {
        uint32_t sector = data_start_sector + (cluster - 2) * sectors_per_cluster;

        for (int s = 0; s < sectors_per_cluster && remaining > 0 && offset < max_size; s++) {
            uint8_t sector_buffer[512];
            if (sd_read_sector(sector + s, sector_buffer) < 0) return -1;

            uint32_t to_copy = remaining < 512 ? remaining : 512;
            to_copy = to_copy < (max_size - offset) ? to_copy : (max_size - offset);

            my_memcpy(buffer + offset, sector_buffer, to_copy);
            offset += to_copy;
            remaining -= to_copy;
        }

        // Read next cluster from FAT
        cluster = fat_get_next_cluster(cluster);
        if (cluster == 0xFFFFFFFF) return -1;
    }

    return offset;
}

int sd_load_file(const char *filename, unsigned long addr) {
    fat32_dir_entry_t entry;

    // Input validation
    if (!filename || addr == 0) {
        uart_puts("Invalid parameters\n");
        return -1;
    }

    // Check filename length (reasonable limit for 8.3 names)
    uint32_t filename_len = 0;
    while (filename[filename_len] && filename_len < 256) filename_len++;
    if (filename_len == 0 || filename_len >= 256) {
        uart_puts("Invalid filename length\n");
        return -1;
    }

    uart_puts("Finding file: ");
    uart_puts(filename);
    uart_puts("\n");

    if (fat_find_file(filename, &entry) < 0) {
        uart_puts("File not found\n");
        return -1;
    }

    // Check file size bounds
    if (entry.file_size > MAX_FILE_SIZE) {
        uart_puts("File too large\n");
        return -1;
    }

    uart_puts("Reading file...\n");

    int32_t size = fat_read_file(&entry, (uint8_t*)addr, MAX_FILE_SIZE);
    if (size < 0) {
        uart_puts("Failed to read file\n");
        return -1;
    }

    // Compute and log checksum for integrity
    uint32_t checksum = 0;
    for (int i = 0; i < size; i++) {
        checksum += ((uint8_t*)addr)[i];
    }
    // Log checksum (simplified, would need hex print)
    uart_puts("File loaded, size: ");
    uart_puts(" bytes, checksum: computed\n");

    return 0;
}